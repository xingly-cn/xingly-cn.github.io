---
title: 目标和 
date: 2021-06-10 08:35:57 
tags: [dfs]
categories: sf 
abbrlink: target-sum 
top_img: transparent 
cover: https://i.loli.net/2021/06/10/tNDOFav9H6JKn2x.png
---

题目直达：[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

#### 题目

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

```bash
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```bash
输入：nums = [1], target = 1
输出：1
```

#### 思路

数组中每一个数字都可以（+，-）两种状态，故可以用动态规划写，这里不做阐述。

这里使用dfs，定义变量：**index**，**sum**，**res**

index ：记录当前pos，如果**index==nums.size()**，说明全部选择完成，如果**sum==target**，res++

sum：记录当前和

res：记录满足条件的数量

#### 代码

```c++
class Solution {
public:
    int res;
    int findTargetSumWays(vector<int>& nums, int target) {
        dfs(nums,0,0,target);
        return res;
    }
    void dfs(vector<int> &nums,int index,int sum,int target){
        if(index == nums.size()){
            if(sum == target) res++;
            return ;   // 即使sum!=target也要返回
        }
        // 每个数字，有（+，-）两种选择
        dfs(nums,index+1,sum+nums[index],target);
        dfs(nums,index+1,sum-nums[index],target);
    }
};
```

2021.6.10二刷
