---
title: 填充每个节点的下一个右侧节点指针 
date: 2021-07-16 08:53:09 
tags: [二叉树,dfs]
categories: sf 
abbrlink: populating-next-right-pointers-in-each-node 
top_img: transparent
cover: https://assets.leetcode.com/uploads/2019/02/14/116_sample.png
---

题目直达：[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

#### 题目

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。初始状态下，所有 next 指针都被设置为 `NULL`。

#### 示例

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```bash
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

#### 思路

总共有两种情况，需要连接。

1. 每个根结点下的子节点需要连接（**等价于连接有相同父节点的两个子节点**），比如<②,③><④,⑤><⑥,⑦>
2. **连接不同父亲的相邻节点**，比如<⑤,⑥>

上面两种情况用代码体现就是这样

```c++
//1.同父亲
connectTwo(root1->left,root1->right);
connectTwo(root2->left,root2->right);
//2.不同父亲
connectTwo(root1->right,root2->left);
```

#### 代码

```c++
class Solution {
public:
    Node* connect(Node* root) {
        if(root == NULL) return NULL;
        connectTwo(root->left,root->right);
        return root;
    }
    void connectTwo(Node* root1,Node* root2){
        if(root1==NULL||root2==NULL) return ;
        // 连接两个节点
        root1->next = root2;
        // 连接相同父节点
        connectTwo(root1->left,root1->right);
        connectTwo(root2->left,root2->right);
        // 连接不同父节点
        connectTwo(root1->right,root2->left);
    }
};
```

2021.7.16二刷
