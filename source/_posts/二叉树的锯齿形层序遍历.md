---
title: 二叉树的锯齿形层序遍历 
tags:
- 二叉树
- 算法
- 双向队列 
categories: sf 
abbrlink: binary-tree-zigzag-level-order-traversal 
date: 2021-04-19 11:11:21
cover: https://z3.ax1x.com/2021/05/28/2FXDk4.png
top_img: transparent
---

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行)

<!-- more -->

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

### 代码

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;		// null 返回
        queue<TreeNode*> q;
        q.push(root);
        bool z = true;		// 标记符 前插or尾插
        while(!q.empty()){
            deque<int> t;		// 双向队列
            int n = q.size();
            for(int i=0;i<n;i++){	// 遍历当前层所有节点
                TreeNode * now = q.front(); q.pop();
                if(z) t.push_back(now->val);	// z为true，尾插
                else t.push_front(now->val);	// z为false，前插
                // 向下一层递归
                if(now->left) q.push(now->left);
                if(now->right) q.push(now->right);
            }
            // emplace_back 等价 push_back 但更高效
            // 将队列中的元素转换成vector插入res
            res.emplace_back(vector<int>{t.begin(),t.end()});
            z = !z;		// 标记改变
        }
        return res;
    }
};
```

### emplace_back和push_back区别

- push_back是先创建元素，复制进vector尾部
- emplace_back是直接在vector尾部创建元素