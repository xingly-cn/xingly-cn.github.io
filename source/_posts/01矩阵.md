---
title: 01矩阵 
date: 2021-06-10 17:24:25 
tags: [bfs]
categories: sf 
abbrlink: 01-matrix 
top_img: transparent 
cover: https://z3.ax1x.com/2021/06/10/22zZz6.png
---

题目直达：[542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

#### 题目

给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。

**示例 1：**

```bash
输入：
[[0,0,0],
 [0,1,0],
 [0,0,0]]

输出：
[[0,0,0],
 [0,1,0],
 [0,0,0]]
```

**示例 2：**

```bash
输入：
[[0,0,0],
 [0,1,0],
 [1,1,1]]

输出：
[[0,0,0],
 [0,1,0],
 [1,2,1]]
```

#### 思路

如果以**1**为出发点，对每个**1**进行bfs寻找最近的**0**，这个思想是有问题的。无法保证当前**1**找到的**0**就是最近的。

如果以**0**为出发点，将所有的**0**加入队列，遍历每个**0**的四周，如果周围有**1**存在那么一定是离**0**最近的。

将这个**点1**的距离更新后，**也要将这个点1加入队列中**，否则只会遍历每个**0**的四周，**示例2中的mat[2\][1]就不会更新**，因为这个点的更新是用它周围的点得来的，所以要将其加入队列。

Tip：初始化时，将非**0**值改为-1，如果遍历到这个值为**-1**，说明没有被更新，这样省去了创建**标记数组**

#### 代码

```c++
class Solution {
public:
    int n,m;
    int dx[4]={0,0,1,-1};
    int dy[4]={1,-1,0,0};
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        n = mat.size(),m = mat[0].size();
        queue<pair<int,int>> q;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(mat[i][j] == 0) q.emplace(i,j);
                else mat[i][j] = -1;
            }
        }
        while(!q.empty()){
            auto [x,y] = q.front(); q.pop();
            for(int i=0;i<4;i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx<0||nx>=n||ny<0||ny>=m||mat[nx][ny]!=-1) continue;
                mat[nx][ny] = mat[x][y] + 1;
                // 必须加上,否则只会遍历0的四周，不会扩散
                // 加上后，已被更新的点，也会搜索它的四周
                q.emplace(nx,ny);
            }
        }
        return mat;
    }

};
```

2021.6.10二刷



