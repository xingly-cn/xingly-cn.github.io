---
title: 验证二叉搜索树 
date: 2021-06-09 20:09:58
tags: [dfs,回溯]
categories: sf 
abbrlink: validate-binary-search-tree 
top_img: transparent
cover: https://z3.ax1x.com/2021/06/06/2Udhv9.jpg
---

题目直达：[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

#### 题目

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

```bash
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```bash
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

#### 思路

由题意知，如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。

`一开始我采用，先序遍历整个树判断每个节点的孩子节点是否满足二叉搜索树的性质，但是这只能保证每个节点的孩子符合要求，但是整体左右子树并没有满足。`

例如：**[5,4,6,null,null,3,7]**，按我的思路那么**6**的孩子节点满足对6的性质，但是6的孩子并没有满足对节点**5**的性质，右子树一定大于根结点值、故错误。

新思路，对每一个节点的值设立**范围区间**，如果不在区间内则返回False，否则向左右递归下去。

#### 参考代码

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        return dfs(root,LONG_MIN,LONG_MAX);
    }
    // 测试样例超过int类型，故用long long
    bool dfs(TreeNode* root,long long left,long long right){
        if(root == nullptr) {
            // 如果到这里还没有跳出，说明已经到最后一个节点
            return true;
        }
        // 不在区间内False
        if(root->val <= left || root->val >= right) return false;
        // 向左右递归，并更新区间
        return dfs(root->left,left,root->val) && dfs(root->right,root->val,right);
    }
};
```

2021.6.9二刷
