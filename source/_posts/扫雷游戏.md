---
title: 扫雷游戏 
date: 2021-06-10 16:56:39 
tags: [dfs,图]
categories: sf 
abbrlink: minesweeper 
top_img: transparent 
cover: https://z3.ax1x.com/2021/06/10/22x7qg.png
---

题目直达：[529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

#### 题目

给定一个代表游戏板的二维字符矩阵。 'M' 代表一个未挖出的地雷，'E' 代表一个未挖出的空方块，'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（'1' 到 '
8'）表示有多少地雷与这块已挖出的方块相邻，'X' 则表示一个已挖出的地雷。

现在给出在所有**未挖出的**方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：

1. 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 **'X'**。
2. 如果一个**没有相邻地雷**的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的**未挖出**方块都应该被递归地揭露。
3. 如果一个**至少与一个地雷相邻**的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。
4. 如果在此次点击中，若无更多方块可被揭露，则返回面板。

**示例 1：**

```bash
输入: 

[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]

输出: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]
```

**解释**

![img](https://i.loli.net/2021/06/10/QN6XUTdgWsxrlyp.png)

**示例 2：**

```bash
输入: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]

输出: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]
```

**解释**

![img](https://i.loli.net/2021/06/10/enaKHEc6bjBTfd4.png)

**注意：**

1. 输入矩阵的宽和高的范围为 [1,50]。
2. 点击的位置只能是未被挖出的方块 ('M' 或者 'E')，这也意味着面板至少包含一个可点击的方块。
3. 输入面板不会是游戏结束的状态（即有地雷已被挖出）。
4. 简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。

#### 思路

**click数组**为下一个点击位置，用（x，y）代表。==矩阵中只有值为**'E'**，才可以被点击==

1. 如果board[x\][y]=**'M'**，说明第一步遇到雷，所以直接更改board[x\][y]=**'X'**。
2. 如果board[x\][y]=**'E'**，首先遍历**此点**周围8个方向，用boom记录周围炸弹数量。如果boom!=0，说明周围有炸弹，将**此点的值**修改为附近炸弹数量**boom**
   。如果boom==0，说明周围没有炸弹，那么标记**此点**为**'B'**，表示已被点击。然后遍历**此点的周围**，如果周围8个点中有**值为'E'**的点，继续遍历这个点，重复下去。

#### 代码

```c++
class Solution {
public:
    int n,m;
    int dx[8] = {-1, 1, 0, 0, -1, 1, -1, 1};
    int dy[8] = {0, 0, -1, 1, -1, 1, 1, -1};
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        n = board.size() , m = board[0].size();
        int x = click[0],y=click[1];    // 第一个点击区域
        if(board[x][y] == 'M') board[x][y] = 'X';  // 踩雷，结束游戏
        else dfs(board,x,y);
        return board;
    }
    void dfs(vector<vector<char>>& board,int x,int y){
        int boom=0; // 当前（x，y）位置，8个方向内的雷数
        for(int i=0;i<8;i++){
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(nx<0||nx>=n||ny<0||ny>=m) continue;  // 越界跳过
            if(board[nx][ny] == 'M') boom++;   // 统计周边雷数
        }
        if(boom!=0){
            board[x][y] = char(boom + '0');     // 当前位置附近有boom个雷
            return ;    // 附近有雷，返回
        }
        board[x][y] = 'B';  // （x，y）这点被点击，变成"B"
        for(int i=0;i<8;i++){
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(nx<0||nx>=n||ny<0||ny>=m) continue;  // 越界跳过
            if(board[nx][ny] == 'E') {   // 只有为"E"，才可以点击它
                dfs(board,nx,ny);   // 遍历周边
            }
        }
    }
};
```

2021.6.10二刷
