---
title: 322.零钱兑换（中等） 
categories: sf 
tags:
- 动态规划
- 贪心 
abbrlink: coinChange 
date: 2021-04-13 12:26:45 
cover: https://z3.ax1x.com/2021/05/28/2FXH1I.jpg
top_img: transparent
---

### 1.分析

1、**确定 base case**，这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、**确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

3、**确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

4、**明确 `dp` 函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp`
函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 `dp`
函数：

`dp(n)` 的定义：输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。

### 2.题目

先看下题目：给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法如下：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        long long dp[10005]={};
        for(int i = 0 ;i <= amount ; i++ ) dp[i] = INT_MAX;	
        dp[0] = 0;		//初始化
        for(int i = 1 ;i <= amount ; i++ ){
            for(int j = 0 ; j < coins.size(); j++ ){		//当coins[i] < i 时判断
                if(coins[j] <= i ) dp[i] = min( dp[i] ,  dp[i-coins[j]] + 1 );
            }
        }
        return dp[amount] == INT_MAX?-1:dp[amount];		//特判
    }
};
```

来源 ：[322-零钱兑换](https://leetcode.com/problems/coin-change/submissions/)

