---
layout: post
title: 三角形最小路径和
date: 2021-07-20 13:30:45
tags: [记忆化递归,自顶向下]
categories: sf
abbrlink: triangle
top_img: transparent
cover: https://pic.leetcode-cn.com/1625727450-rTgsdr-111.png
---

### [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

**示例 1：**

```bas
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

**示例 2：**

```bash
输入：triangle = [[-10]]
输出：-10
```

### 思路

首先要知道，记忆化递归（自顶向下），动态规划（自底向上）

<img src="https://pic.leetcode-cn.com/1625727450-rTgsdr-111.png"  alt="一枚方糖">

分析题知道，**triangle\[i][j]** 的最小值取决于**triangle\[i+1][j]** 和 **triangle\[i+1][j+1]**，不断递归当前位置的**下**和**下右** ，每次更新 **dp\[i][j]** 为最小值，当**i**到达最底层结束。

记忆化递归是什么？记录每次的结果，如果已经计算过就直接返回，无需再次计算，直接返回

```c++
// 记忆化
if(dp[i][j]) return dp[i][j];
```

### 代码

```c++
class Solution {
public:
    int dp[200][200];
    int minimumTotal(vector<vector<int>>& triangle) {
        return dfs(triangle,0,0);
    }
    int dfs(vector<vector<int>>& triangle,int i,int j){
        // 边界
        if(i==triangle.size()) return 0;
        // 记忆化
        if(dp[i][j]) return dp[i][j];
        //递归
        return dp[i][j] = min(dfs(triangle,i+1,j),dfs(triangle,i+1,j+1)) + triangle[i][j];
    }
};

```

