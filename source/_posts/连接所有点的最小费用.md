---
layout: post
title: 连接所有点的最小费用
date: 2021-08-25 17:05:25
tags: [图,方糖算法,最小生成树]
categories: sf
abbrlink: leetcode-graph-min-cost-to-connect-all-points
top_img: transparent
cover: https://s3.bmp.ovh/imgs/2021/08/fe9f81ed2a54414e.png
---

题目直达：[1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

# 连接所有点的最小费用

给你一个`points` 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。

连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 **曼哈顿距离** ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 `val` 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。

**示例 1：**![img](https://i.loli.net/2021/08/25/MSXG2dkqDfeVUwo.png)

```
输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
输出：20
```

# 思路

- 邻接表转化
- 并查集板子

这里做了一个优化，就是把`merge`函数设置为`int`型，让他同时具有`合并`和判断是否`连通`两个作用。

判断两个点的根节点是否相同来实现。

# 代码

乍一看还真长，其实一大半是板子。`淡定淡定`

```c++
class Solution {
public:
    // 根结点，高度
    vector<int> root,height;  

    // 初始化
    void init(int n){   
        root.resize(n);
        height.resize(n,1);
        for(int i=0;i<n;i++) root[i]=i;
    }

    // 路径压缩
    int find(int x){
        return x==root[x]?x:root[x]=find(root[x]);
    }

    // 合并优化
    int merge(int x,int y){
        int rootx = find(x);
        int rooty = find(y);
        if(rootx==rooty) return false;  // 已连通返回
        if(height[rootx]>height[rooty]) root[rooty] = rootx;
        else if(height[rootx]<height[rooty]) root[rootx] = rooty;
        else {
            root[rooty] = rootx;
            height[rootx]++;
        }
        return true;    //  告知未连通
    }


    // 存储边权
    struct Edge {
        int x,y,v;  // 起点，终点，权值
        Edge(int x,int y,int v) : x(x),y(y),v(v){}  // 构造函数
    };

    int minCostConnectPoints(vector<vector<int>>& points) {
        // 计算曼哈顿距离
        auto dist = [=](int x,int y) -> int {
            return abs(points[x][0]-points[y][0]) + abs(points[x][1]-points[y][1]);
        };

        // 初始化
        int n = points.size();
        init(n);
        vector<Edge> mp;

        // 建图
        for(int i=0;i<n;i++) {
            for(int j=i+1;j<n;j++) {
                mp.emplace_back(i,j,dist(i,j));    
            }
        }

        // 按权值排序
        sort(mp.begin(),mp.end(),[](Edge a,Edge b) -> int{ return a.v < b.v; });
        
        // sum为总权值，t为节点数
        int sum=0,t=1;
        for(auto [x,y,v]:mp) {
            if(merge(x,y)) {
                sum += v;
                t++;
            }
            if(t == n) break;
        }
        return sum;
    }
};
```

