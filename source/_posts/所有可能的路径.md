---
title: 所有可能的路径 
date: 2021-06-10 19:59:29 
tags: [dfs]
categories: sf 
abbrlink: all-paths-from-source-to-target 
top_img: transparent
cover: https://i.loli.net/2021/06/10/mTpxeMt3VF4ALk7.jpg
---

题目直达：[797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

#### 题目

给一个有 `n` 个结点的有向无环图，找到所有从 `0` 到 `n-1` 的路径并输出（不要求按顺序）

二维数组的第 `i` 个数组中的单元都表示有向图中 `i` 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了。

**示例 1：**

![img](https://i.loli.net/2021/06/10/Twnh9Y23OzQNLcx.jpg)

```bash
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

**示例 2：**

![img](https://i.loli.net/2021/06/10/mTpxeMt3VF4ALk7.jpg)

```ba
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

**示例 3：**

```bash
输入：graph = [[1],[]]
输出：[[0,1]]
```

**示例 4：**

```bash
输入：graph = [[1,2,3],[2],[3],[]]
输出：[[0,1,2,3],[0,2,3],[0,3]]
```

**示例 5：**

```bash
输入：graph = [[1,3],[2],[3],[]]
输出：[[0,1,2,3],[0,3]]
```

#### 思路

定义**cur**为当前点，对起点**0**进行dfs，如果**cur==n-1**说明找到，将**最后一个点加入path**，再将**path**加入结果**res**中。接着对当前点可以**到达的所有点**继续进行dfs。

#### 代码

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int n;
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        n = graph.size(); 
        dfs(graph,0,path);
        return res;
    }
    void dfs(vector<vector<int>>& graph,int cur,vector<int> path){
        if(cur == n-1){   // 找到n-1了
            // 如果不加这一行，会缺少终点
            path.push_back(cur);  // 将最后一个点加入
            res.push_back(path);  // 将路径加入res中
            return ;
        }
        path.push_back(cur);
        for(int i=0;i<graph[cur].size();i++){   // 遍历cur可以到达的所有点
            dfs(graph,graph[cur][i],path);  // 将cur可到达的点加入path
        }
    }
};
```

2021.6.10二刷
