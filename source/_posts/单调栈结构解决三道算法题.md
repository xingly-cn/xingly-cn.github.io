---
layout: post
title: 单调栈结构解决三道算法题
date: 2021-08-19 16:16:10
tags: [方糖算法,单调栈]
categories: sf
abbrlink: dandiao-stack2
top_img: transparent
cover: https://img.asugar.cn/asugar/sf.jpg
---

# 单调栈结构解决三道算法题

读完本文，还可以顺便去 LeetCode 上拿下他们：

| 单调栈经典模板题                                             |
| :----------------------------------------------------------- |
| [496.下一个更大元素I（简单）](https://leetcode-cn.com/problems/next-greater-element-i) |
| [503.下一个更大元素II（中等）](https://leetcode-cn.com/problems/next-greater-element-ii) |
| [739.每日温度（中等）](https://leetcode-cn.com/problems/daily-temperatures/) |

单调栈只是利用了一些逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

听起来有点像堆？并不是，单调栈用于处理一种典型问题，叫做**下一个最大元素**。

# 单调栈模板

现在给你出这么一道题：给你一个数组 `nums`，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。

函数签名如下：

```cpp
vector<int> nextGreaterElement(vector<int>& nums);
```

比如说，输入一个数组 `nums = [2,1,2,4,3]`，你返回数组 `[4,2,4,-1,-1]`。

解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

```cpp
// 写法一
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> res(nums.size()); // 存放答案的数组
    stack<int> s;
    // 倒着往栈里放
    for (int i = nums.size() - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.empty() && s.top() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的 next great number
        res[i] = s.empty() ? -1 : s.top();
        s.push(nums[i]);
    }
    return res;
}

// 写法二 (个人喜好)
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> res(nums.size()); // 存放答案的数组
    stack<int> s;
    // 倒着往栈里放
    for (int i = 0; i < nums.size(); i++) {
        // 判定个子高矮
        while (!s.empty() && s.top() <= nums[i]) {
 			res[s.top()] = nums[i];
            s.pop();
        }
        s.push(nums[i]);
    }
    return res;
}
```

---

# 问题变形

给你一个数组 `T`，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：**对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0**。

函数签名如下：

```cpp
vector<int> dailyTemperatures(vector<int>& T);
```

比如说给你输入 `T = [73,74,75,71,69,76]`，你返回 `[1,1,3,2,1,0]`。

相同的思路，上面模板是栈记录元素，现在改为记录元素下标即可，开冲

```cpp
// 写法一
vector<int> dailyTemperatures(vector<int>& T) {
    vector<int> res(T.size());
    // 这里放元素索引，而不是元素
    stack<int> s; 
    /* 单调栈模板 */
    for (int i = T.size() - 1; i >= 0; i--) {
        while (!s.empty() && T[s.top()] <= T[i]) {
            s.pop();
        }
        // 得到索引间距
        res[i] = s.empty() ? 0 : (s.top() - i); 
        // 将索引入栈，而不是元素
        s.push(i); 
    }
    return res;
}

// 写法二 （个人喜好）
vector<int> dailyTemperatures(vector<int>& T) {
    vector<int> res(T.size());
    // 这里放元素索引，而不是元素
    stack<int> s; 
    /* 单调栈模板 */
    for (int i = 0; i < T.size(); i++) {
        while (!s.empty() && T[s.top()] <= T[i]) {
            res[s.top()] = i - s.top(); 
            s.pop();
        }
        // 将索引入栈，而不是元素
        s.push(i); 
    }
    return res;
}
```

---

# 处理环形数组

比如输入一个数组 `[2,1,2,4,3]`，你返回数组 `[4,2,4,-1,4]`。拥有了环形属性，**最后一个元素 3 绕了一圈后找到了比自己大的元素 4**。

一般是通过 % 运算符求模（余数），来获得环形特效：

```cpp
int[] arr = {1,2,3,4,5};
int n = arr.length, index = 0;
while (true) {
    print(arr[index % n]);
    index++;
}
```

**难点在于，比如输入是 `[2,1,2,4,3]`，对于最后一个元素 3，如何找到元素 4 作为 Next Greater Number。**

==方法①==**对于这种需求，常用套路就是将数组长度翻倍**：

![](https://s3.bmp.ovh/imgs/2021/08/9d3aa60166025ca2.jpeg)

==方法②==**循环数组**

**我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果**。

```cpp
// 方法一
vector<int> nextGreaterElements(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n);
    stack<int> s;
    // 假装这个数组长度翻倍了
    for (int i = 2 * n - 1; i >= 0; i--) {
        // 索引要求模，其他的和模板一样
        while (!s.empty() && s.top() <= nums[i % n]){
            s.pop();
        }
        res[i % n] = s.empty() ? -1 : s.top();
        s.push(nums[i % n]);
    }
    return res;
}

// 方法二 （个人喜好）
vector<int> nextGreaterElements(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n);
    stack<int> s;
    // 假装这个数组长度翻倍了
    for (int i = 0; i < 2 * n; i++) {
        // 索引要求模，其他的和模板一样
        while (!s.empty() && s.top() <= nums[i % n]){
            res[s.top()] = nums[i % n];
            s.pop();
        }
        s.push(nums[i % n]);
    }
    return res;
}
```

这样，就可以巧妙解决环形数组的问题，时间复杂度 `O(N)`。
