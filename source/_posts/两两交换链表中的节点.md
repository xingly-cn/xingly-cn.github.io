---
title: 两两交换链表中的节点 
date: 2021-04-29 17:12:31 
tags: [链表,迭代]
abbrlink: swap-nodes-in-pairs 
categories: sf 
cover: https://z3.ax1x.com/2021/05/28/2FOfij.gif
top_img: transparent
---

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是**单纯的改变节点内部的值**，而是需要实际的进行节点交换。

<!-- more -->

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

## 题目

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是**单纯的改变节点内部的值**，而是需要实际的进行节点交换。

**示例 1：**

![img](https://i.loli.net/2021/04/29/Hv3oDGIVA2dkWm5.jpg)

```c++
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```c++
输入：head = []
输出：[]
```

**示例 3：**

```c++
输入：head = [1]
输出：[1]
```

---

## 思路：

![image-20210429172607669](https://i.loli.net/2021/04/29/PhLpMYFxKC4NGUs.png)

1. 首先创建哑节点dummyHead 指向head，temp指向哑节点，node1、node2分别指向temp的下一个，下下一个节点。

![image-20210429172626076](https://i.loli.net/2021/04/29/PnaAKW4FeVXTkHD.png)

![image-20210429172847624](https://i.loli.net/2021/04/29/UdIhZu1iJgG9jx4.png)

2. temp指向node2，node1指向node2的下一个节点，node2指向node1。

   完成一次交换。

![image-20210429172913592](https://i.loli.net/2021/04/29/JnzuOSyWd5crBK4.png)

3. 最后移动temp到node1节点。切记不是node2，因为node1、node2已经

   交换完成了。重复（123步骤）

## 代码

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode * root = new ListNode(0);  // 头空节点
        root->next = head;
        ListNode * temp = root;
        while(temp->next!=nullptr && temp->next->next!=nullptr){
            ListNode *node1 = temp->next;
            ListNode *node2 = temp->next->next;
            temp->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            temp = node1;   // 注意：不是node2，此时节点已经交换了
        }
        return root->next;
    }
};
```

