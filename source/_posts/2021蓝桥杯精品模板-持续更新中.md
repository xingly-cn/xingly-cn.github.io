---
title: 2021蓝桥杯精品模板 - 持续更新中 
date: 2021-04-17 20:01:05 
tags: [蓝桥杯,算法,模板]
abbrlink: lanqiao2021 
categories: sf 
cover: https://z3.ax1x.com/2021/05/28/2FX6pR.jpg
top_img: transparent
---

2021蓝桥杯精品模板 - 持续更新中

<!-- more -->

### 1. 高级数据结构

#### 1.1 并查集

```c++
const int N=10005;
int f[N],h[N];
void init(){	// 初始化
    for(int i=1;i<=N;i++) {
        f[i]=i;		
        h[i]=0;		// 树高为0
    }
}
int sou(int x){		// 路径压缩
    if(x!=f[x]) f[x]=sou(f[x]);
    return f[x];
}
void merge(int x,int y){	// 合并优化
    x = sou(x);
    y = sou(y);
    if(h[x]==h[y]){	
        h[x]++;
        f[y]=x;
    }else{
        if(h[x]<h[y]) f[x]=y;	// 与树高，低的那一个连接
        else f[y]=x;
    }
}
```

### 2. 字符串

#### 2.1 KMP算法

```c++
const int maxn = 1005;
char str[maxn],pattern[maxn];
int next[maxn],cn;		// next数组 计算失配后j回溯的位置
void init(char *p,int plen){	// 计算next数组
    next[0]=0,next[1]=0;
    for(int i=1;i<plen;i++){
        int j=next[i];
        while(j&&p[i]!=p[j]) j=next[j];
        next[i+1]=(p[i]==p[j])?j+1:0;
    }
}
int kmp(char *s,char *p){	// kmp
    int slen=strlen(s),plen=strlen(p);
    init(p,plen);
    int j=0;
    for(int i=0;i<slen;i++){
        while(j&&s[i]!=p[j]) j=next[j];
        if(s[i]==p[j]) j++;
        if(j==plen){
            cn++;   // p在s中出现次数
            // 题意发挥
        }
    }
    return cn;
}
```

### 3. 数论

**前言：模运算，加减乘满足分配率，除法需要逆元求解**

#### 3.1 gcd

```c++
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
```

#### 3.2 lcm

```c++
int lcm(int a,int b){
    return a/gcd(a,b)*b;
}
```

#### 3.3 快速幂（快速乘）

```c++
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
const int p = 10000007;
inline ll ksc(ll x,ll y){	// 快速乘
    ll t=(ld)x/p*y;
    ll res=(ull)x*y-(ull)t*p;
    return (res+p)%p;
}
ll fast(ll di,ll zhi){	 // 快速幂
    ll res=1;
    while(zhi>0){
        if(zhi&1) res=ksc(res,di);		// 替换快速乘
        zhi>>=1;
        di=ksc(di,di);		// 替换快速乘
    }
    return res;
}
```

#### 3.4 欧拉筛

```c++
const int maxn = 10000;
int prime[maxn],vis[maxn];
int doprime(int n){
    int cn=0;	//
    memset(vis,0,sizeof(vis));
    memset(prime,0,sizeof(prime));
    for(int i=2;i<=n;i++){
        if(!vis[i]) { vis[i]=i,prime[cn++]=i; }
        for(int j=0;j<cn;j++){
            if(i*prime[j]>n) break;
            vis[i*prime[j]]=prime[j];
            if(i%prime[j]==0) break;
            
        }
    }
    return cn;	 // [1,n]的素数个数 
}
```

#### 3.5 质因数分解

```c++
void divide(int x){
    for(int i=2;i<=x/i;i++){
        if(x%i==0){
            int cn=0;
            while(x%i==0) x/=i,cn++;	// 重复几个
            cout<<i<<"-"<<cn<<endl;		// 可存入数组
        }
    }
    if(x>1) cout<<x<<"-"<<1<<endl; 		// 剩余处理
}
```

### 4. 二叉树

#### 4.1 最小生成树

```c++
#include<bits/stdc++.h>
using namespace std;
struct maps{          //存图
	int u,v,w;
}a[200005];
int f[5005],n,m,ans,cnt;
bool cmp(maps a,maps b){  //按权排序
	return a.w<b.w;
}
int sou(int x){  // 路径压缩
	if(x!=f[x]) f[x]=sou(f[x]);
	return f[x];
}
void akuba(){
	sort(a,a+m,cmp);
	for(int i=0;i<m;i++){
		int eu=sou(a[i].u);
		int ev=sou(a[i].v);
		if(eu==ev) continue;   //若两点已连通则，这条边不需要计算
		ans+=a[i].w;   //这条边计算
		f[ev]=eu;    //合并
		cnt++;
		if(cnt==n-1) break;  //边数=点-1
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) f[i]=i;  //初始化并查集
	for(int i=0;i<m;i++) cin>>a[i].u>>a[i].v>>a[i].w;
	akuba();
	cout<<ans<<endl;
	return 0;
}
```

### 5. 动态规划

#### 5.1 最大连续子序列和

```c++
int a[maxn],dp[maxn];		// 存储
dp[0] = a[0];		// base case
for(int i=1;i<n;i++){		// 状态转移
	dp[i] = max(a[i],dp[i-1]+a[i]);
}
```

#### 5.2 最长公共子序列

```c++
int dp[100][100];		// 存储
for(int i=0;i<=a.size();i++) dp[i][0]=0; 	// base case
for(int i=0;i<=b.size();i++) dp[0][i]=0;	// base case
for(int i=1;i<=a.size();i++){		// 状态转移
	for(int j=1;j<=b.size();j++){
		if(a[i]==b[j]) dp[i][j] = dp[i-1][j-1] + 1;
		else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
	}
}
```

#### 5.3 最长上升子序列

```c++
int a[1000],dp[1000];		// 存储
for(int i=0;i<n;i++){
	dp[i] = 1;		// base case
	for(int j=0;j<i;j++){		// 状态转移
		if(a[j]<=a[i] && dp[j]+1>dp[i]){
			dp[i] = max(1,dp[j]+1);
		}
	}
}
```

#### 5.4 最长回文子串

```c++
int ans = 1;
char mp[1000];
int dp[1000][1000]={};		// 存储
for(int i=0 ; i<strlen(mp) ; i++){		// base case
	dp[i][i] = 1;
   	if(i < strlen(mp) - 1){
		if(mp[i] == mp[i+1]){
			dp[i][i+1] = 1;
			ans = 2;
 		}
	}
}
for(int L=3 ; L<=strlen(mp) ; L++){ // 枚举子串长度
	for(int i=0 ; i+L-1<strlen(mp) ; i++){ // 枚举子串左端点
		int j = i+L-1; // 子串右端点
		if(mp[i] == mp[j] && dp[i+1][j-1]) {
			dp[i][j] = 1;
			ans = L;
		}
	}
}
```

#### 5.5 背包

```c++
int w[100],c[100],dp[1000];		// 存储
for(int v=0 ; v<=V ; v++) dp[v] = 0;	// base case
for(int i=1 ; i<=n ; i++){		// 状态转移
	for(int v=V; v>=w[i] ; v--){
		dp[v] = max(dp[v],dp[v-w[i]]+c[i]);
	}
}
```

#### 5.6 完全背包

```c++
int w[100],c[100],dp[1000];		// 存储
for(int v=0 ; v<=V ; v++) dp[v] = 0;	// base case
for(int i=1 ; i<=n ; i++){		// 状态转移
	for(int v=w[i]; v<=V ; v++){
		dp[v] = max(dp[v],dp[v-w[i]]+c[i]);
	}
}
```

### 6. 算法小技巧

#### 6.1 快读

```c++
inline int read(){
    char ch=getchar();
    int x=0,f=1;    // x求和 y判断负数
    while(ch<'0'||ch>'9'){   // 过滤非数字
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){    // 读入数字
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```