---
layout: post
title: 结构化绑定解包返回值
date: 2021-09-07 21:25:40
tags: [c++17]
categories: other
abbrlink: chapter1-1-chinese
top_img: transparent
cover: https://p.pstatp.com/origin/pgc-image/5e90a62ded0e4bd69999291ce2103f57
---

# 使用结构化绑定来解包绑定的返回值

C++17配备了一种新的特性——`结构化绑定`，其可以结合语法糖来自动推导类型。

并可以从组对、元组和结构体中提取单独的变量。

# 如何使用

我们先看C++17之前是如何实现，再来看C++17如何实现：

## pair类型

- 假设一个函数`divide`，需要输入除数和被除数，返回整数和余数，使用`pair`绑定这两个值 

```c++
pair<int,int> divide(int x,int y)
```

C++17之前：

```cpp
auto res = divide(5,2);
cout<<res.first<<" "<<res.second;
```

C++17：

```c++
auto [x,y] = divide(5,2);
cout<<x<<" "<<y;
```

## 结构体

```c++
struct people{
    int age;
    string name;
};
```

C++17：

```c++
vector<people> peoples;
for(auto [id,name] : peoples){
	cout<<id<<" "<<name;
}
```

# 支持类型

- pair
- tuple
- struct
- array

> Note:
>
> 不仅为了性能，还必须确保在适当的时刻使用引用，尽量减少不必要的副本。

如果中括号中变量不够，那么编译器将会报错:

```c++
std::tuple<int, float, long> tup(1, 2.0, 3);
auto [a, b] = tup; // Does not work
```

# 更多

STL 中的基础数据结构都能通过结构结构化绑定直接进行访问，而无需修改任何东西。

循环中打印`map`中的元素

```c++
map<string,int> animal_population {
  {"humans", 7000000000},
  {"chickens", 17863376000},
  {"camels", 24246291},
  {"sheep", 1086881528}
};

for (const auto &[species, count] : animal_population) {
	cout <<"There are "<<count <<" "<<species<<" on this planet.";
}
```

