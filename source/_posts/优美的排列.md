---
title: 优美的排列 
date: 2021-06-10 08:48:16 
tags: [dfs]
categories: sf 
abbrlink: beautiful-arrangement 
top_img: transparent 
cover: https://z3.ax1x.com/2021/06/06/2Udhv9.jpg
---

题目直达：[526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)

#### 题目

假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：

- 第 **i** 位的数字能被 **i** 整除
- **i** 能被第 **i** 位上的数字整除

现在给定一个整数 N，请问可以构造多少个优美的排列？

**示例1:**

```bash
输入: 2
输出: 2
解释: 

第 1 个优美的排列是 [1, 2]:
  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除

第 2 个优美的排列是 [2, 1]:
  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
```

**说明:**

**N** 是一个正整数，并且不会超过15。

#### 思路

定义变量**index**，记录当前pos。如果**index>n**，说明全部找完返回，并且res++。

每一次遍历完，找到符合要求的让**index+1**，寻找下一个，重新遍历找到符合要求的......

直到index>n，结束。

#### 代码

```c++
class Solution {
public:
    int res;
    bool vis[16];
    int countArrangement(int n) {
        dfs(1,n);
        return res;
    }
    void dfs(int index,int n){
        if(index > n) {
            res++;
            return ;  // 数组满足[1,n],大于n返回
        }
        // 注意[1,n]个数，每个数只能用一次
        for(int i=1;i<=n;i++){
            if((i%index==0 || index%i==0) && !vis[i]) {
                vis[i] = true;  // 标记i已使用
                dfs(index+1,n); // 找下一个
                vis[i] = false; // 回溯
            }
        }
    }
};
```

2021.6.10二刷
