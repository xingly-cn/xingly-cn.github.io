---
layout: post
title: 子串的最大出现次数
date: 2021-08-09 14:05:35
tags: [滑动窗口]
categories: sf
abbrlink: maximum-number-of-occurrences-of-a-substring
top_img: transparent
cover: https://img.asugar.cn/blog/leetcode.jpg
---

题目直达：[1297. 子串的最大出现次数](https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/)

# 题目

​	给你一个字符串 `s` ，请你返回满足以下条件且出现次数最大的 **任意** 子串的出现次数：

- 子串中不同字母的数目必须小于等于 `maxLetters` 。
- 子串的长度必须大于等于 `minSize` 且小于等于 `maxSize` 。

**示例 1：**

```bash
输入：s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
输出：2
```

**示例 2：**

```bash
输入：s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
输出：2
```

**示例 3：**

```bash
输入：s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
输出：3
```

# 思路

​	**重点**：==题目给的maxSize其实没有用，因为子串越短，长子串一定会包含短子串，题目要求最大出现次数，所以肯定用最短的长度计算==。

​	由上我们知道了**窗口大小**为**minSize**，剩下的就简单了。

​	不断滑动窗口，当前窗口内不同的字符数量（set统计）小于等于**maxLetters**，加入map集合并统计次数，每次遇到满足的窗口，更新**res**最大值。

# 代码

​	由于这题目标是字符串，所以可以用**string**的方法直接移出窗口左边的字符，因为窗口大小不变，所以每次只要删除**字符的第一位**，即**`temp.erase(0,1);`**。我当时把**0**写成了**i**，竟然忘了这是**string**字符串，导致删除窗口左边的字符（删错位置了，**debug好久才找出来的，哭了**）。

​	如果这题不是字符串而是**vector\<object>**，那就需要动态删除窗口左边的位置，这时候写**i**，就没问题了，惭愧惭愧！

```c++
class Solution {
public:
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        int i = 0,j = 0,res = 0;
        string temp = "";
        unordered_map<string,int> q;
        unordered_set<char> st;
        for(j;j<minSize;j++) {
            st.insert(s[j]);
            temp+=s[j]; 
        }
        if(st.size()<=maxLetters) {q[temp]++;res++;}
        // 建立窗口
        while(j<s.size()){
            st.clear();
            temp.erase(0,1); i++;	// 这里是痛点
            temp+=s[j]; j++;
            for(char x:temp) st.insert(x);
            if(st.size()<=maxLetters){
                q[temp]++;
                res = max(res,q[temp]);    
            }
        }
        return res;
    }
};
```

