---
layout: post
title: 数据流的中位数
date: 2021-08-27 17:18:15
tags: [对顶堆,方糖算法]
categories: sf
abbrlink: find-median-from-data-stream
top_img: transparent
cover: https://s3.bmp.ovh/imgs/2021/08/f5d845ce6d32cccf.jpg
---

## 题目直达：[295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)

# 题目

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如：

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

- void addNum(int num) - 从数据流中添加一个整数到数据结构中。

- double findMedian() - 返回目前所有元素的中位数。

## **示例：**

```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```



# 技巧

题目的意思就是，每次插入数组，然后随时取出中位数。有人说我不可以每次插入后sort一下吗？但是这样肯定超时，有人还说每次插入我用二分使他有序，也会超时。

所以我们用到了`对顶堆`，由（大顶堆+小顶堆）构成，通常用来`动态维护第k大的值`（比如中位数）。

![Snipaste_2021-08-27_17-53-06](https://i.loli.net/2021/08/27/CLIwb4HE2NFytZo.png)

- 我们以`小根堆堆顶`为标准，如果插入的数大于它则加入小根堆，否则加入大根堆。

- 当两边元素个数相差超过1，则将多的一边元素弹出，加入少的一边
- 求中位数，两个堆中个数多的那一个的堆顶，若相同则取两个堆顶求平均值

```c++
priority_queue<int> big; //大根堆
priority_queue<int, vector<int>, greater<int> > small; //小根堆 
 
inline void insert(int x)
{
	if(small.empty() || x > small.top()) small.push(x);
    else big.push(x);
    if(big.size() > small.size() + 1) { small.push(big.top()); big.pop(); }
	if(small.size() > big.size() + 1) { big.push(small.top()); small.pop(); }	
} 
```

# 代码

```c++
class MedianFinder {
public:
    priority_queue<int> big;
    priority_queue<int,vector<int>,greater<int>> small;

    MedianFinder() {
    }
    
    void addNum(int num) {
        if(small.empty() || num > small.top()) small.push(num);
        else big.push(num);
        if(big.size() > small.size() + 1) { small.push(big.top()); big.pop(); }
	    if(small.size() > big.size() + 1) { big.push(small.top()); small.pop(); }	
    }
    
    double findMedian() {
        if(small.size() > big.size()) return small.top();
        else if(small.size() < big.size()) return big.top();
        else return (small.top() + big.top())*0.5;
    }
};
```

